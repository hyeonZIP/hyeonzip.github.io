{"componentChunkName":"component---src-templates-md-files-js","path":"/BOJ-1260-DFS와BFS/","result":{"data":{"markdownRemark":{"html":"<h1>0. 문제 링크</h1>\n<p><a href=\"https://www.acmicpc.net/problem/1260\">>>[BOJ] 1260번: DFS와 BFS&#x3C;&#x3C;</a></p>\n<h1>1. 문제 이해</h1>\n<p>BFS와 DFS에 대한 기초 지식 문제</p>\n<h1>2. 자료구조,알고리즘 선택</h1>\n<p>처음 풀이에서는 dfs = 재귀함수, bfs = queue로 공식처럼 생각했기에 별 생각없었다.</p>\n<blockquote>\n<p>Q. dfs는 재귀함수 말고 다른 방법은 없나?</p>\n<blockquote>\n<p>A. stack을 이용해서 구현이 가능하다. 다만,<br>\n<a href=\"https://vanslog.io/posts/language/java/why-use-deque-instead-of-stack/\">>>해당 블로그&#x3C;&#x3C;</a> 에서 설명하는 것을 간단히 표현하면,<br>\nVector: 동기화 O, 쓰레드 안전 O, 속도 느림<br>\nArrayList: 동기화 X, 쓰레드 안전 X, 속도 빠름<br>\n*Stack은 Vector를 상속받아 만들어짐<br>\n따라서 Deque(양방향 큐)를 사용해 stack 구현</p>\n</blockquote>\n<p>Q. BFS는 queue 말고 다른 방법은 없나?</p>\n<blockquote>\n<p>A. 얕게 검색을 한건지 몰라도 현재는 queue가 일반적이다.</p>\n</blockquote>\n</blockquote>\n<h1>3. 시간복잡도 계산</h1>\n<p>입력값 for문 + dfs의 for문 + bfs의 for문 = O(N+M) + O(N+M) + O(N+M) 임으로 3*O(N+M)...</p>\n<p>인줄 알았으나 시간 복잡도의 표기 이유는 입력 크기가 매우 커졌을 때의 성능을 표기하기위한 것이기 때문에</p>\n<p>상수값은 무시하여 O(N+M)으로 계산을 마무리 할 수 있다.</p>\n<h1>4. 다른 풀이</h1>\n<p>인접 행렬과 인접 리스트 라는 용어를 알게 되었다.</p>\n<p><code>int[][] map;</code> &#x3C;&#x3C; 이게 인접 행렬 <code>List&#x3C;Integer>[] adj;</code> &#x3C;&#x3C; 이것이 인접 리스트</p>\n<p>기존에 알고 있던 인접 행렬의 원리는 map[1][2] 로 바로 이동이 가능하다면</p>\n<p>인접 리스트에서는 adj[1]로 이동해서 for(int n : adj[1])을 통해 2가 있는지 확인해야한다.</p>\n<p>따라서 이번 문제와 같이 희소 그래프에서는 인접 리스트로 구현해도 가능하지만</p>\n<p>미로 찾기와 같은 map의 크기가 커질 경우 인접 행렬을 이용해야 한다.</p>\n<p>또, 기존에는 방문 배열을 초기화해 주기 위해 <code>visited = new boolean[N+1]</code> 으로 새 인스턴스를 생성했다면</p>\n<p><code>Arrays.fill(visited, false);</code>를 이용해 chill 하게 초기화 해줄 수 있다.</p>\n<h1>5. 전체 풀이</h1>\n<pre><code>package problemSolving;\r\n\r\n/*\r\n * 1. DFS / BFS 사용\r\n * 2. 정점 번호가 작은 것을 먼저 방문\r\n */\r\n\r\nimport java.util.*;\r\nimport java.io.*;\r\n\r\npublic class Main {\r\n\t\r\n\tstatic int N;\r\n\tstatic int M;\r\n\tstatic int V;\r\n\t\r\n\tstatic int[][] map;\r\n\t\r\n\tstatic boolean[] visited;\r\n\t\r\n\tstatic String result;\r\n\t\r\n\tstatic StringBuilder sb = new StringBuilder();\r\n\t\r\n\tstatic Queue&#x3C;Integer> q = new LinkedList&#x3C;>();\r\n\t\r\n\tpublic static void main(String[] args) throws IOException{\r\n\t\t\r\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\r\n\t\t\r\n\t\t\r\n\t\tN = Integer.parseInt(st.nextToken());//정점 개수\r\n\t\tM = Integer.parseInt(st.nextToken());//간선 개수\r\n\t\tV = Integer.parseInt(st.nextToken());//시작 정점 번호\r\n\t\t\r\n\t\tmap = new int[N+1][N+1];//정점 간 연결 정보\r\n\t\tvisited = new boolean[N+1];//정점 방문 정보\r\n\t\t\r\n\t\t\r\n\t\tfor(int i=0; i&#x3C;M; i++) {\r\n\t\t\tst = new StringTokenizer(br.readLine());\r\n\t\t\tint x = Integer.parseInt(st.nextToken());\r\n\t\t\tint y = Integer.parseInt(st.nextToken());\r\n\t\t\t\r\n\t\t\tmap[x][y] = 1;\r\n\t\t\tmap[y][x] = 1;\r\n\t\t}\r\n\t\tdfs(V);\r\n\t\tsb.append(\"\\n\");\r\n\t\tvisited = new boolean[N+1];\r\n//\t\tArrays.fill(visited, false);\r\n\t\tq.offer(V);\r\n\t\tvisited[V] = true;\r\n\t\tbfs();\r\n\t\tSystem.out.println(sb);\r\n\t}\r\n\t\r\n\tpublic static void dfs(int startNode) {\r\n\t\tsb.append(startNode).append(\" \");\r\n\t\tvisited[startNode] = true;\r\n\t\t\r\n\t\tfor(int i=1; i&#x3C;=N; i++) {\r\n\t\t\t\r\n\t\t\tif(map[startNode][i] == 1 &#x26;&#x26; !visited[i]) {\r\n\t\t\t\tdfs(i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static void bfs() {\r\n\t\t\r\n\t\twhile(!q.isEmpty()) {\r\n\t\t\t\r\n\t\t\tint startNode = q.poll();\r\n\t\t\t\r\n\t\t\tsb.append(startNode).append(\" \");\r\n\t\t\t\r\n\t\t\tfor(int i=1; i&#x3C;=N; i++) {\r\n\t\t\t\tif(map[startNode][i] == 1 &#x26;&#x26; !visited[i]) {\r\n\t\t\t\t\tq.offer(i);\r\n\t\t\t\t\tvisited[i] = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n        }\r\n\t}\r\n}\n</code></pre>","frontmatter":{"date":"January 31, 2025","title":"[BOJ] 1260번: DFS와 BFS [JAVA]","tag":"BOJ,DFS,BFS","thumbnail":null}}},"pageContext":{"slug":"/BOJ-1260-DFS와BFS"}},"staticQueryHashes":["3649515864","63159454"],"slicesMap":{}}